# GPIO Pin Definitions
substitutions:
  door_relay_pin: "GPIO16"
  buzzer_relay_pin: "GPIO17"
  door_open_sensor_pin: "GPIO4"
  door_closed_sensor_pin: "GPIO5"
  status_led_pin: "GPIO23"
  auto_close_timer_minutes: "16"

# Adjustable timer in HA
number:
  - platform: template
    id: auto_close_minutes
    name: "Garage Auto-Close Timer"
    optimistic: true
    min_value: 1
    max_value: 60
    step: 1
    initial_value: $auto_close_timer_minutes
    - globals.set:
        id: my_global_number
        value: !lambda 'return id(countdown).state;'

# Countdown globals
globals:
  - id: countdown
    type: int
    restore_value: no
    initial_value: $auto_close_timer_minutes

# Expose countdown to HA
sensor:
  - platform: template
    id: countdown_sensor
    name: "Garage Auto-Close Countdown"
    unit_of_measurement: "min"
    lambda: |-
      return id(countdown);

esphome:
  name: garagedoorcontroller
  friendly_name: GarageDoorController
  
  on_boot:
    priority: -10
    then:
      - if:
          condition:
            and:
              - binary_sensor.is_on: door_open
              - binary_sensor.is_off: door_closed
          then:
            - lambda: |-
                id(countdown) = (int)id(auto_close_minutes).state;
                ESP_LOGI("autoclose", "Boot: Door is open, countdown started (%d min)", id(countdown));
            - sensor.template.publish:
                id: countdown_sensor
                state: !lambda "return id(countdown);"

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "Cf3EmdudHs3h5j8vaJgNBpMPAud7mTdroWUlntZmh6k="

ota:
  - platform: esphome
    password: "6d351604b5fd33550beee807e096f724"

wifi:
  networks:
  - ssid: !secret wifi_ssid
    password: !secret wifi_password
  - ssid: !secret 2_wifi_ssid
    password: !secret 2_wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Garagedoorcontroller"
    password: "mLo5Yica0zgq"

captive_portal:

web_server:
  port: 80

status_led:
  pin: ${status_led_pin}

# Relay outputs
switch:
  - platform: gpio
    id: door_relay
    name: "Garage Door Relay"
    pin: ${door_relay_pin}
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: gpio
    id: buzzer_relay
    name: "Garage Buzzer Relay"
    pin: ${buzzer_relay_pin}
    restore_mode: RESTORE_DEFAULT_OFF

# Reed switches
binary_sensor:
  - platform: gpio
    pin: 
      number: $door_open_sensor_pin
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Garage Door Open"
    filters:
      - delayed_on: 10ms
    id: door_open
    device_class: garage_door

  - platform: gpio
    pin: 
      number: $door_closed_sensor_pin
      mode: 
        input: true
        pullup: true
      inverted: true
    name: "Garage Door Closed"
    filters:
      - delayed_on: 10ms
    id: door_closed
    device_class: garage_door

# Cover entity
cover:
  - platform: template
    name: "Garage Door"
    id: garage_door
    device_class: garage
    open_action:
      - switch.turn_on: buzzer_relay
      - delay: 500ms
      - switch.turn_off: buzzer_relay
      - delay: 500ms      
      - switch.turn_on: buzzer_relay
      - delay: 500ms
      - switch.turn_off: buzzer_relay
      - switch.turn_on: door_relay
      - delay: 250ms
      - switch.turn_off: door_relay
    close_action:
      - switch.turn_on: buzzer_relay
      - delay: 500ms
      - switch.turn_off: buzzer_relay
      - delay: 500ms      
      - switch.turn_on: buzzer_relay
      - delay: 500ms
      - switch.turn_off: buzzer_relay
      - delay: 500ms
      - switch.turn_on: buzzer_relay
      - delay: 500ms
      - switch.turn_on: door_relay
      - delay: 250ms
      - switch.turn_off: door_relay
      - delay: 2s
      - switch.turn_off: buzzer_relay
    stop_action:
      - switch.turn_on: door_relay
      - delay: 500ms
      - switch.turn_off: door_relay
    optimistic: false
    assumed_state: false
    lambda: |-
      if (id(door_closed).state) {
        return COVER_CLOSED;
      } else if (id(door_open).state) {
        return COVER_OPEN;
      } else {
        return {};
      }


# Timer logic
interval:
  - interval: 1min
    then:
      - if:
          condition:
            and:
              - binary_sensor.is_on: door_open
              - binary_sensor.is_off: door_closed
          then:
            - lambda: |-
                if (id(countdown) > 0) {
                  id(countdown) -= 1;
                  ESP_LOGI("autoclose", "Countdown: %d minutes left", id(countdown));
                }
            - sensor.template.publish:
                id: countdown_sensor
                state: !lambda "return id(countdown);"
            - if:
                condition:
                  lambda: 'return id(countdown) == 0;'
                then:
                  - cover.close: garage_door
          else:
            - lambda: |-
                id(countdown) = 0;
            - sensor.template.publish:
                id: countdown_sensor
                state: 0
